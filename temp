
void ft_printf(char *str,long time,int index,t_philo *philos)
{

	pthread_mutex_lock(&philos->p);

	printf(str,time,index);

	pthread_mutex_unlock(&philos->p);

}

void philos_actions(t_philo *philos)
{
 
	pthread_mutex_lock(&philos->forks);

	ft_printf("%ld philosopher %d has taken a fork\n",(get_time() - philos->start),philos->index + 1,philos);
	
	pthread_mutex_lock(philos->next_forks);

	ft_printf("%ld philosopher %d has taken a fork\n",(get_time() - philos->start),philos->index + 1,philos);
	
	philos->p_info->last_time_eat = get_time() - philos->start;
	
	ft_printf("%ld philosopher %d eating...\n",(get_time() - philos->start), philos->index + 1,philos);
 
	usleep(philos->p_info->time_to_eat * 1000);
	 
	pthread_mutex_unlock(&philos->forks);
	 
	pthread_mutex_unlock(philos->next_forks);
	 
	ft_printf("%ld philosopher %d sleeping...\n",(get_time() - philos->start), philos->index + 1,philos);
	
	usleep(philos->p_info->time_to_sleep * 1000);
	 
	ft_printf("%ld philosopher %d thinking\n",(get_time() - philos->start), philos->index + 1,philos);

	// philos->p_info->t_must_eat--;

	
}


void *philosophers(void *p)
{
	struct philo *philos;

	philos = (struct philo *)p;


	while (philos->p_info->t_must_eat || philos->infini_loop)// 5 4
		philos_actions(philos);
	return NULL;
}


void create_threads(t_philo *philos,t_philo_info *info)
{
	int i = 0;
	
	while ( i < philos[0].number_of_philo)
	{
		pthread_create(&philos[i].id_of_philo,NULL,philosophers,(void*)&philos[i]);
		usleep(100);
		i++;
	}
	i = 0;
	while ( i < philos[0].number_of_philo)
	{
		pthread_join(philos[i].id_of_philo, NULL);
		i++;
	}

}

























philos = init_philos(argv,argc,philos);
		philos->start = get_time();
		circle_philos(philos);
		create_threads(philos,info);